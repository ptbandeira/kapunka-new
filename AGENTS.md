# AGENTS.md

# I. Read Me First: Core Mandates

## Rolling Log Update Requirement

* After every significant Decap/Netlify change, append a new entry to `docs/decap-netlify-rolling-log.md` documenting what was updated and why.
* Use the following command to add entries quickly (the script appends directly to `docs/decap-netlify-rolling-log.md`):
  * `npx zx scripts/update-rolling-log.mjs docs/decap-netlify-rolling-log.md`
* When logging work, note that the build copies `content/` into `.netlify/visual-editor/content/`; no manual mirroring into `site/content/` is required.

This document guides autonomous coding agents (Codex/LLMs) operating on the project codebase.

## The Revised Golden Rule

* **DO NOT** modify the site’s structural "spine" (layout grids, core navigation/header/footer components, or section component contracts).
* **EXCEPTION:** The sole permissible structural change to the site spine is the injection of Visual Editor data attributes (`data-sb-object-id` and `data-sb-field-path`). These changes must not alter existing classes, styling, or functionality **[Constraint from previous instructions]**.

## Core Objectives

* Any new content addition must be editable via the Visual Editor (inline or page editor).
* When fixing issues, treat AI-generated code as a draft, not a final version.
* Prioritize code quality, consistency, and maintenance (clean code principles) over raw speed.

---

# II. Visual Editor Annotation and Synchronization Protocol

Inline editing is made possible by annotating HTML elements using specific data attributes that map content on the rendered page back to the content source schema.

## A. Non-Invasive Annotation Rules

The agent must locate the appropriate JSX/TSX/HTML rendering components and inject the following attributes:

* **`data-sb-object-id` (Document Context):**
  This attribute must be present on an ancestor element (or the element itself) to scope all descendant elements within the context of the unique content document ID.

  * If using Git CMS, the ID value must be the path to the source file, relative to the project root, including the extension.
  * If rescoping to a referenced document, apply a new `data-sb-object-id`.

* **`data-sb-field-path` (Field Mapping):**
  This attribute identifies the specific field within the document that needs to be editable.

  * The field path must match the field name in the content schema (model definition), not a local variable or component property name.
  * When possible, use dot notation (`author.name`) for nested objects or index notation for lists (`items.0.title`).
  * For advanced targeting (like attributes), use XPath notation (e.g., `#@src`).

## B. Configuration and Conflict Check (Two-Way Sync Integrity)

The agent must perform a deep scan of configuration files to ensure the Two-Way Content Sync mechanism is stable, especially looking for previous conflicts:

* **CSI/Visual Editor Configuration:** Audit `stackbit.config.ts/js` and related model definition files for:

  * **Conflicting Content Sources:** Identify and flag/remove redundant definitions of content sources (e.g., legacy CMS configurations) that might interfere with the current Content Source Interface (CSI). CSI modules are used by the Visual Editor dev server, not the site code itself.
  * **Model Validation:** Ensure all content files are properly mapped to a defined model, especially if using a file-based Git CMS.
  * **Authentication:** Confirm that the configuration relies on environment variables (like access tokens) that are set correctly in the Netlify UI, as these are critical for the cloud container to load and modify data.

---

# III. Code Quality and Bloat Elimination Mandate

The AI agent must proactively search for and eliminate architectural bloat and redundancies that degrade performance and complicate maintenance (which trash the LLM’s context window).

## A. Redundancy and Bloat Removal

* **Remove Duplicate Code:** Identify and eliminate identical or nearly identical logic blocks, favoring consolidation via abstraction (functions, utilities, or shared modules).
* **Remove Dead Code and Journal Comments:** Eliminate uncalled or unused functions, commented-out sections (legacy code), and unnecessary journal comments (`@author`, dates, etc.). Version control handles history.
* **Simplify Complex Logic:** Refactor overly complex or convoluted functions generated by AI or human developers, preferring straightforward solutions and adhering to the Single Responsibility Principle (SRP).

## B. Consistency and Cleanliness

* **Naming Conventions:** Rename vague AI-suggested variable or function names (e.g., `temp1`) to be meaningful, searchable, and consistent with project vocabulary (e.g., `orderTotal`).
* **Context and Comments:** Ensure that code is generally self-explanatory, using comments only to explain complex logic or non-obvious AI-generated solutions.
* **Hard-Coded URLs:** Avoid hard-coded external URLs or credentials; rely on Netlify Environment Variables or CMS-driven fields.

---

# IV. Project Overview and Testing Requirements

* **Framework:** Vite-powered React single-page app (`HashRouter` + React Router DOM routes).
* **Language:** TypeScript across app, contexts, and pages (`tsconfig.json`).
* **Testing:** Run `npm run build` to ensure compilation succeeds before PR.

---

# V. Execution and PR Guidelines (Agentic Workflow)

To ensure high-quality, non-breaking changes, the agent must employ detailed specification (similar to Chain-of-Thought prompting, which yields measurable gains):

* **Summarize Conflicts and Sequence Changes:** The plan must summarize configuration conflicts and outline the sequence of structural changes (annotations/refactors).
* **Limit Edits and Provide Context:** Changes must be scoped tightly (bite-sized updates) to avoid unintended side effects across multiple files. The agent must leverage the available codebase context during reasoning.
* **Deliver Minimal Diff and Tests:** The final deliverable must be a minimal diff containing only necessary code additions and corrections.
* **Risk Mitigation:** Require a rollback strategy for critical changes.
* **Final Check:** Confirm Visual Editor bindings are intact and running successfully locally after applying changes.

---

# VI. Media Delivery, CMS Editing Model, and Git Hygiene

## A. Cloudinary Image Pipeline

* `CLOUDINARY_BASE_URL` is injected by Vite (`vite.config.ts`) and must remain the single source for the Cloudinary cloud name + upload root.
* All media assets are committed to `/static/images/uploads` and referenced via the CMS. When rendering them in React/TSX, wrap the stored path with `toCld()` from `src/lib/images.ts` so the helper trims legacy prefixes and concatenates the base URL safely.
* Skip `toCld()` only when you can prove the source is already an absolute `https://` URL (the helper performs this guard, so it is typically safe to call unconditionally).
* Never inline hard-coded Cloudinary domains; rely on the environment variable so staging and production share the same transformation pipeline.

## B. CMS Editing Model (Single-File Pages)

* Page content is consolidated inside `content/pages_v2/index.json`. Each entry represents a full page and must stay self-contained.
* The `sections` arrays inside each page are mirrored by collapsible groups in the Netlify Visual Editor. Preserve these group boundaries when adding, reordering, or deleting blocks so editors retain predictable collapse behaviour.
* Localised copy and metadata values are stored as objects keyed by locale (`en`, `pt`, `es`). Each locale renders as a tab in the editor; keep values as objects (not flattened strings) so editors can switch tabs without losing context. Always populate every locale key whenever you add a field.
* When introducing new schema fields, update `metadata.json` and the Visual Editor mirror in a single commit to prevent drift.

## C. Branch and Commit Conventions

* Stay on the branch provided in the task (no new branches, no rebasing onto `main`).
* Write focused commits with [type](https://www.conventionalcommits.org/en/v1.0.0/)-prefixed, imperative subjects (e.g., `feat:`, `fix:`, `chore:`). Never use `git commit -am` or force-push; stage files explicitly so history stays reviewable.
* Run required checks before committing, document the results, and prefer minimal diffs that keep rollbacks trivial.
